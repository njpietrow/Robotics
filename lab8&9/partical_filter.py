import numpy as npimport mathimport scipy.statsimport scipy.miscimport Particle as Particleimport lab8_mapimport copyclass ParticleFilter:    def __init__(self):        self.current_x = .5        self.current_y = .5        self.current_theta = 0        self.map_x = 3        self.map_y = 3        self.prob_cutoff = .05        self.num_particles = 1000        self.std_d = .03        self.std_theta = .03        self.std_sonar = .15        temp_xs = np.random.uniform(0, 3, self.num_particles)        temp_ys = np.random.uniform(0, 3, self.num_particles)        temp_thetas = np.random.uniform(0, 2 * math.pi, self.num_particles)        temp_prob = 1/self.num_particles        self.Particle_List = []        self.p_List = []        for x in range(self.num_particles):            self.p = Particle.Particle(temp_xs[x], temp_ys[x], temp_thetas[x], temp_prob)            self.p_List.append(temp_xs[x])            self.p_List.append(temp_ys[x])            self.p_List.append(0)            self.p_List.append(temp_thetas[x])            self.Particle_List.append(self.p)        self.map = lab8_map.Map("lab8_map.json")    def Movement(self, distance, theta, turn):        for particle in self.Particle_List:            adj = 0            turn_adj = 1            if turn:                adj = theta                turn_adj = 0            particle.update(distance + turn_adj * np.random.normal(0, self.std_d),                            particle.theta + adj + np.random.normal(0, self.std_theta))        self.Cropping()    def Cropping(self):        i = 0        while i < self.num_particles:            if self.Particle_List[i].x > self.map_x:                self.Particle_List[i].x = 3            elif self.Particle_List[i].x < 0:                self.Particle_List[i].x = 0            elif self.Particle_List[i].y > self.map_y:                self.Particle_List[i].y = 3            elif self.Particle_List[i].y < 0:                self.Particle_List[i].y = 0            i += 1    def Sensing(self, distance):        for particle in self.Particle_List:            d = self.map.closest_distance((particle.x, particle.y), particle.theta)            p_sensor = math.log(scipy.stats.norm(distance, self.std_sonar).pdf(d))            prob = p_sensor + particle.prob            particle.prob = prob        self.Particle_List.sort(key=lambda x: -x.prob)        for i in range(int(len(self.Particle_List) / 2)):            self.Particle_List[i + int(len(self.Particle_List) / 2)] = copy.deepcopy(self.Particle_List[i])        probs = []        for particle in self.Particle_List:            probs.append(particle.prob)        prob_sum = pow(math.e, scipy.misc.logsumexp(probs))        for particle in self.Particle_List:            particle.prob = math.log(pow(math.e, particle.prob) / prob_sum)        # print("----sum----")        # print(prob_sum)        pos,theta = self.Estimation()        return pos, theta    def Estimation(self):        X = 0        Y = 0        theta = 0        prob_total = 0        for particle in self.Particle_List:            X += particle.x * pow(math.e, particle.prob)            Y += particle.y * pow(math.e, particle.prob)            theta += particle.theta * pow(math.e, particle.prob)            prob_total += pow(math.e, particle.prob)        print("[%.6f]=Y" % X)        print("[%.6f]=X" % Y)        print("[%.6f]=Theta " % theta)        return(X, Y,0), theta